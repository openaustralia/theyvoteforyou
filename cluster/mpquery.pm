# $Id: mpquery.pm,v 1.8 2003/10/04 13:46:22 frabcus Exp $
# This extracts a vote distance metric for a set of MPs, and is able to
# write it out in a format for loading into GNU Ooctave (or MatLab)

# The Public Whip, Copyright (C) 2003 Francis Irving and Julian Todd
# This is free software, and you are welcome to redistribute it under
# certain conditions.  However, it comes with ABSOLUTELY NO WARRANTY.
# For details see the file LICENSE.html in the top level of the source.

package mpquery;
use strict;

sub get_mp_ixs
{
    my $dbh = shift; 
    my $where = shift;
    my $limit = shift;

    my $sth = db::query($dbh, "select pw_mp.mp_id from pw_mp, pw_cache_mpinfo where
        pw_mp.mp_id = pw_cache_mpinfo.mp_id and $where 
        order by pw_mp.last_name, pw_mp.first_name, pw_mp.constituency $limit");
    my @mp_ixs;
    while (my @data = $sth->fetchrow_array())
    {
        push @mp_ixs, $data[0];
    }
    return \@mp_ixs;
}

sub vote_distance_metric
{
    my $dbh = shift;
    my $mp_ixs = shift;
    my $clause = shift;

    # Count divisions
    my $sth = db::query($dbh, "select division_id from pw_division $clause");
    print $sth->rows . " division\n";
    my @div_ixs;
    while (my @data = $sth->fetchrow_array())
    {
        push @div_ixs, $data[0];
    }

    # Read all votes in, and make array of MPs and their vote in each division
    my $limit = " where (mp_id = " . join(" or mp_id = ", @$mp_ixs) . ")";
    $limit .= " and (division_id = " . join(" or division_id = ", @div_ixs) . ")";
    $sth = db::query($dbh, "select division_id, mp_id, vote from pw_vote $limit");
    print $sth->rows . " votes\n";
    my @votematrix;
    while (my @data = $sth->fetchrow_array())
    {
        my ($div_dat, $mp_dat, $vote) = @data;
        my $votescore = undef;
        $votescore = 1 if ($vote eq "aye");
        $votescore = -1 if ($vote eq "noe");
        $votescore = 0 if ($vote eq "both");
        die "Unexpected $vote voted" if (!defined $votescore);
        
        $votematrix[$mp_dat][$div_dat] += $votescore;
    }

    # Create matrix of "distances" between MPs
    my @metricD;
    for my $mp_1 (@$mp_ixs)
    {
        for my $mp_2 (@$mp_ixs)
        {
            # Only do half triangle
            next if $mp_1 > $mp_2;

            # For the pair of MPs, tot up which divisions they voted the same in
            my $divs_both_at = 0;
            my $divs_voted_same = 0;
            for my $div_ix (@div_ixs)
            {
                my $vote1 = $votematrix[$mp_1][$div_ix];
                my $vote2 = $votematrix[$mp_2][$div_ix];
                $vote1 = 0 if (!defined $vote1);
                $vote2 = 0 if (!defined $vote2);
                if ($vote1 != 0 and $vote2 != 0)
                {
                    $divs_both_at++;
                    if ($vote1 == $vote2)
                    {
                        $divs_voted_same++;
                    }
                }
            } 

            # Create score based on this
            if ($divs_both_at != 0)
            {
                $metricD[$mp_1][$mp_2] = ($divs_both_at - $divs_voted_same) / $divs_both_at;
            }
            elsif ($mp_1 == $mp_2)
            {
                $metricD[$mp_1][$mp_2] = 0; # No-voters, like Gerry Adams need this clause
            }
            else
            {
                $metricD[$mp_1][$mp_2] = 1;
            }
        }
    }

    return \@metricD;
}

sub octave_writer
{
    my $fh = shift;
    my $dbh = shift;
    my $mp_ixs = shift;
    my $metricD = shift;

    use POSIX qw(strftime);
    my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $fh "# Autogenerated by mpquery::octave_writer from The Public Whip project on $now_string\n\n";

    # Print it all out
    for my $mp_1 (@$mp_ixs)
    {
        my $sthmp = db::query($dbh, "select last_name, first_name, party from pw_mp where mp_id=?", $mp_1);
        die "Wrong number of rows back" if $sthmp->rows != 1;
        my @data = $sthmp->fetchrow_array();
        my ($lastname, $firstname, $party) = @data; 

        print $fh "na" . $mp_1 . " = \"" . $lastname . ", " . $firstname . "\";\n";
        print $fh "pa" . $mp_1 . " = \"" . $party . "\";\n";
        print $fh "r" . $mp_1 . " = [";
        for my $mp_2 (@$mp_ixs)
        {
            print $fh "," if ($mp_2 != $$mp_ixs[0]);
            if ($mp_1 <= $mp_2)
            {
                print $fh $$metricD[$mp_1][$mp_2];
            }
            else
            {
                print $fh $$metricD[$mp_2][$mp_1];
            }
        }
        print $fh "];\n";
    }

    print $fh "D=[\n";
    foreach my $mp_ix (@$mp_ixs)
    {
        print $fh "r" . $mp_ix . ";";
    }
    print $fh "];\n";

    print $fh "ns=[\n";
    for my $mp_ix (@$mp_ixs)
    {
        print $fh "na" . $mp_ix . ";";
    }
    print $fh "];\n";

    print $fh "ps=[\n";
    for my $mp_ix (@$mp_ixs)
    {
        print $fh "pa" . $mp_ix . ";";
    }
    print $fh "];\n";
}

1;
